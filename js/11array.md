# 数组

## 内存中连续存储多个数据的存储空间，再起一个名字

## 连续存储的一组数据，可极大提高程序的执行效率

## 只要存储多个数据都要用数组

## 创建

### 1. 创建空数组

#### 数组直接量

##### var arr=[]

#### 用new

##### var arr=new Array();

### 2. 创建数组同时初始化数组元素

#### 数组直接量

##### var arr=[值1, 值2,...]

#### 用new

##### var arr=new Array(值1,值2,...);

### 3. 创建n个空元素的数组

#### 用new

##### var arr=new Array(n)

## 访问

### arr[i]

#### 用法和单个变量完全一样

#### 三个不限制

##### 不限制元素的数据类型

##### 不限制元素个数: 可随时在任意位置添加新元素

##### 不限制下标越界

-   取值:不报错,返回undefined

-   赋值:不报错，自动在指定位置创建新元素

-   稀疏数组:下标不连续的数组,自动将length调整到最大下标+1

## 关联数组

#### 可自定义下标名称的数组

##### vs 索引数组

-   下标都是数字的数组

### 为什么

#### 索引数组的下标没有意义，只能通过遍历查找指定的元素内容

##### 查找速度受数组元素个数和元素位置的影响

### 何时

#### 希望通过下标名称快速查找某个元素时

##### 不受元素个数和元素存储位置的影响

#### 创建

##### 2步

-   创建空数组:var hash=[]

-   向数组中添加新元素:hash["下标名(key)"]=值(value)

#### 访问

##### hash["下标名(key)"]

-   用法同访问索引数组中的元素

#### 特点

##### .length是属性始终为0

##### 无法使用索引数组的API

#### 遍历

```
for(var key in hash){
    key //仅获取当前下标名称
    hash[key] //获取当前元素值
}
```

##### 固定套路

-   仅获取hash中的所有key

```
var keys=[];
var i=0;
for(keys[i++] in hash);
//结束后: keys中保存了hash的所有key
```

## 数组API

### .length属性

#### 规定了数组理论上的元素个数

#### 始终等于最大下标+1

#### 固定套路

##### 获取最后一个元素: arr[arr.length-1]

##### 获取倒数第n个元素:arr[arr.length-n]

##### 末尾追加一个新元素arr[arr.length]=值

##### 缩容

-   删除末尾元素:arr.length--

-   删除末尾n个元素:arr.length-=n

-   清空数组:arr.length=0

### 遍历

#### 依次取出数组中每个元素的值，执行相同的操作

##### 只要对数组中每个元素执行相同操作时

```
 for(var i=0;i<arr.length;i++){
   arr[i] //当前数组元素
}
```

### 转字符串

#### String(arr)

##### 将arr中每个元素转为字符串，用逗号链接

#### arr.join("连接符")

##### 将arr中每个元素转为字符串，可自定义连接符

##### 固定套路

-   无缝拼接:arr.join("")

-   判断空数组:arr.join("")===""

-   动态生成页面元素:'<开始标签>'+arr.join("</结束标签><开始标签>")+"</结束标签>"

### 拼接和选取

#### 拼接

##### var newArr=arr1.concat(值1,值2,arr2,....)

-   将值1,值2,arr2中的每个元素，拼接到arr1结尾

##### 强调: 

-   无权修改原数组，只能返回新数组，必须用变量接住返回值

-   可自动打散数组类型的参数为单个数值，再拼接

#### 选取

##### var subArr=arr.slice(starti,endi+1);

-   选取arr中starti位置到endi位置的元素，组成新数组返回

##### 强调:

-   无权修改原数组，只能返回新数组，必须用变量接住返回值

-   凡是两个参数都是下标的API:含头不含尾

-   省略第二个参数: 从starti一直选取到结尾

-   省略全部两个参数: 复制整个数组

-   负数参数:倒数第n个自动执行length-n

-   固定套路: 获得i位置开始的n个元素:arr.slice(i,i+n)


######  用途:将类数组对象转化为数组对象:Array.prototype.slice.call(arguments)




### 修改数组

#### 删除元素

##### arr.splice(starti,n)

-   删除arr中starti位置开始的n个元素

##### 强调:

-   直接修改原数组

-   不用考虑含头不含尾

##### 简写:

-   省略第二个参数:删除starti位置后所有元素

-   支持负数参数，表示倒数第n个

##### 其实有返回值

-   返回被删除的元素组成的临时数组

-   var deletes=arr.splice(starti,n)

#### 插入元素

##### arr.splice(starti,0,值1,值2,...)

-   在arr中starti位置插入新值，原starti位置的值及其之后的值被向后顺移

##### 强调:

-   不支持打散数组类型参数:如果插入子数组，会变成二维数组

#### 替换

##### arr.splice(starti,n,值1,值2...)

-   先删除arr中starti位置的n个元素，再在starti位置插入新元素

##### 强调:

-   删除的元素个数不一定和插入的元素个数一致

#### 固定套路

##### 广告轮播

-   移除开头的n个元素到结尾:imgs=imgs.concat(imgs.splice(0,n))

-   移除结尾的n个元素到开头:imgs=imgs.splice(-n).concat(imgs)

### 翻转

#### arr.reverse()

### 排序

#### 手写排序: 

##### 冒泡，快速，插入

#### arr.sort()

##### 将arr中每个元素转为字符串，再按字符串升序排列

##### 问题: 

-   只能按字符串升序排列

##### 自定义比较器函数


1. 定义比较器函数专门比较两个值大小的函数

-  2个要求:1. 两个参数a,b/2. 返回值


-  最简单的数字升序比较器:function compare(a,b){return a-b;}

2. 将比较器函数作为对象传入sort方法

-  arr.sort(compare)


3.其实都会简写为: 

-  arr.sort(function(a,b){return a-b;})

##### 降序排列

-   颠倒比较器函数返回值的正负号

-   数字降序比较器:function compare(a,b){return b-a;}

### 栈和队列

#### js中没有专门的栈和队列的结构，都是用普通数组模拟的

#### 栈:

##### 一端封闭只能从另一端进出得数组

##### FILO

-   结尾出入栈:arr.push(值)/arr[arr.length]=值

-  出:var last=arr.pop()

-   开头出入栈:arr.unshift(值)

-  出:var first=arr.shift()

#### 队列

##### 只能从一端进入，从另一端出的数组

##### FIFO

-   结尾入

-   开头出

## 二维数组

### 什么是

#### 数组中的元素内容，又是一个子数组

### 何时使用

#### 1. 保存横行竖列的二维数据

#### 2. 对大的数组中的元素，再进行细分类

### 如何使用

##### 1. 先创建空数组，再赋值

-   var arr=[];

-   arr[i]=[值1,值2,...]

##### 2. 在创建数组同时，初始化子数组

-   var arr=[
   [值1,值2,...],
   [值1,值2,...],
]

#### 访问

##### arr[r][c]

-   用法和普通数组元素的用法完全一样

-   任何情况下r不能越界,否则报错！

#### 遍历:

```
for(var r=0;r<arr.length;r++){
   for(var c=0;c<arr[r].length;c++){
      arr[r][c] //当前元素
   }
}
```
