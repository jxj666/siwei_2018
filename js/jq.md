# jQuery

##### 快速，简洁的第三方js库

# 精髓

### 1. DOM操作的终极简化

- 核心DOM: 万能, 但繁琐
- HTML DOM: 简单，但不是万能
- jQuery: 对DOM操作的终极简化


1. 增，删，改，查
2. 事件
3. 动画效果
4. Ajax

### 2. 屏蔽了浏览器兼容性问题

例如:

- 1.x版本兼容IE8
- 2.x不再兼容IE8



# 查找

### 1.基本选择器

#### #id  / .class /   element  /  *   /  选择器1,选择器2


### 2.层次选择器

#### 选择器1空格选择器2  /  >  /   +   /    ~



### 3.过滤选择器

#### - 基本过滤(位置过滤)

##### 根据元素在查找结果集合中的下标选择元素

###### 和元素在其父元素下的位置无关

##### :first/last

###### 选择结果集合中第一个/最后一个元素

##### :even/odd

###### 选择结果集合中下标为偶数或奇数的元素

###### 强调:下标从0开始

##### :eq/gt/lt(i)

###### 选择结果集合中下标等于/大于/小于i位置的元素

#### - 子元素过滤

##### 根据元素在其父元素中的位置选择

###### 和元素在查找结果中的位置无关

##### :first-child

##### :last-child

##### :nth-child(n/odd/even/2n/2n+1)

###### 强调: 下标从1开始，且仅限于当前父元素内

##### :only-child

#### - 否定选择器: 

##### :not(任意selector)

#### - 内容过滤

##### :contains(文本)

##### :empty

##### :parent

###### :not(:empty)

##### :has('selector')

#### - 可见性过滤

##### :visible

##### :hidden

###### display:none

###### input type="hidden"

#### - 属性过滤

##### [属性名]

##### [属性名=值]

##### [属性名!=值]

##### [属性名^=开头]

##### [属性名$=结尾]

##### [属性名*=值]

#####  [属性选择器1][属性选择器2]...

#### - 表单过滤

##### :input

###### input, select, textarea, button

###### 如果只想查找一种表单元素:可用元素选择器

##### :type属性

###### :text  :password   :checkbox   :radio    :button    :submit   :reset       :image       :file

#### 表单属性过滤

##### :disabled    :enabled      :checked       :selected

### 4.节点间关系

#### 父子关系

##### $("...").children(["selector"])

###### 仅找直接子元素中符合selector条件的

##### $("...").find("selector")

###### 在所有后代中查找符合selector条件的

##### $("...").parent()

###### 获得当前元素的父元素

#### 兄弟关系

##### $("...").next/prev(["selector"])

###### 紧邻的前一个或后一个兄弟元素:必须紧邻


##### $("...").nextAll/prevAll(["selector"])

###### 之后/之前所有符合条件的兄弟

##### $("...").siblings(["selector"])

###### 除自己之外的所有兄弟





# API通用特点

### 1. 几乎所有API自带forEach的效果

#### 对$("...")执行的操作，相当于自动应用到查询结果中每个元素上

### 2. 每个API都返回jQuery对象本身

#### $("...")之后可使用链式操作反复调动多个API

#### 为什么链式操作

##### 1. 避免重复创建jq对象

###### 每次调用$都会创建新的jq对象

##### 2. 节省变量的使用

### 3. 很多API两用

#### 传一个参数是读取属性值，传两个参数就是修改属性值




# 修改

### 属性

#### 访问attribute属性

##### 获取

###### var value=$("...").attr("属性名")

##### 修改

###### 只修改一个属性

$("...").attr("属性名",值)

###### 同时修改多个属性

$("...").attr({
    属性名:值,
    属性名:值,
})

#### 访问三大状态

##### 包括: disabled    checked     selected

##### $("...").prop(...)

###### 用法同attr()

#### 移除属性

##### $("...").removeAttr/removeProp("属性名")

### 内容

#### html内容

##### $("...").html(["html代码片段"])

###### 两用

#### 文本内容

##### $("...").text([“文本内容”])

###### 两用

#### 表单元素内容

##### $("...").val(["值"])

###### 两用

#### 清除内容

##### $("...").empty()

### 样式

#### 直接修改css属性

##### 获取css样式(计算后的样式)

###### $("...").css("css属性名")

##### 修改css样式

###### 只修改一个css样式:

$("...").css("css属性名",值)

###### 同时修改多个css样式: 

$("...").css({
    css属性名:值,
    css属性名:值,
    ...
})

#### 通过修改class批量修改样式

##### 判断是否包含指定class

###### $("...").hasClass("类名")

##### 添加class

###### $("...").addClass("类名")

##### 移除class

###### $("...").removeClass("类名")

##### 切换class

###### $("...").toggleClass("类名")



# 添加，删除，替换和复制

### 添加

#### 1. 创建新元素

##### var $newElem=$("html代码片段")

#### 2. 将新元素添加到DOM树

##### 结尾/开头插入

###### $(parent).append/prepend($newElem)

##### 在某个child前后插入

###### $(child).before/after($newElem)

### 删除

#### $("...").remove()

### 替换

#### $("现有元素").replaceWith("新元素html代码")

##### 用右替换左

#### $("新元素html代码").replaceAll("现有元素")

##### 用左替换右

### 复制/克隆

#### $("...").clone()

##### 浅克隆

###### 仅复制属性，不复制行为

#### $("...").clone(true)

##### 深克隆

###### 即复制属性，又复制行为





# 事件

### .bind("事件名",fn)

#### .unbind('事件名',fn)

#### .unbind('事件名')

#### .unbind()

### .on("事件名",fn)

### 简化版

#### $("...").事件名(function(e){...})

### $("parent").delegate("selector","事件名",fn)

#### 简化了利用冒泡中:

##### 1. 用selector代替了if判断

##### 2. this->e.target

### $("selector").live/die("事件名",fn)

#### 已废弃

### 终极简化

#### 仅为一个元素绑定事件

##### $("...").on("事件名",fn)

#### 利用冒泡/事件委托

##### $("parent").on("事件名","selector",fn)

### this

#### 触发事件的当前元素对象

##### DOM对象

###### $(this)

变为jq对象

#### 利用冒泡

##### this->e.target

### 模拟触发

#### $("...").trigger("事件名")

##### 模拟触发所有选中元素的指定事件

### 页面加载后触发

#### window.onload=function(){...}

##### 晚:整个页面加载完才执行:等待HTML，CSS，JS，图片...



#### $(document).ready(fn)

##### 早:只要DOM内容加载完成就触发:只要等待HTML , js



##### $().ready(fn)

###### $(fn)

#### 其实

##### 只要将script代码放在body结尾就可以解决





# 动画效果

### 简单:

#### 显示隐藏

##### $("...").show/hide/toggle(speed,easing,callback)

#### 上下滑动

##### $("...").slideUp/slideDown/slideToggle(speed,easing,callback)

#### 淡入淡出

##### $("...").fadeIn/fadeOut/fadeToggle(speed,easing,callback)

#### 问题： 

##### 不便于维护

#### 解决

##### 其实都应该用

###### class + transition

### 万能
$("...").animate({
    css属性: 目标值,
    css属性: 目标值,
    ...
},speed,easing,callback)


##### 多个css属性并发改变

#### 问题

##### 仅对数值类型的属性有效

##### 对颜色,字体,C3的变换...无效

#### callback中的this->正在播放动画的DOM元素

#### 多个动画串行执行

##### $("...").animate().animate()...

#### 停止:

##### $("...").stop(true)

#### 选择器: 

##### :animated

###### 匹配所有正在执行动画效果的元素

### 问题: 

#### 底层依然是定时器动画，效率低

### 解决: 

#### animate.css



# 封装自定义插件

### 添加jQuery全局函数

#### jQuery库在加载时仅会向window中注入一个对象jQuery

#### jQuery全局函数

##### 直接保存在jQuery库中，不需要查询结果就可直接调用的函数

##### vs window全局函数

###### 保存在window下，容易造成全局污染

##### vs jQuery实例方法

###### 保存在查询结果对象的原型对象(jQuery.fn)中的方法

###### 必须先查询结果集合，再用结果集合调用:this->指jQuery查询结果集合


##### each 用法

###### $.each:直接保存在jQuery对象中,可遍历任意类数组对象和数组

###### $(...).each:jQuery查询结果集合的原型对象中,只能用jQuery查询结果集合调用

#### 何时

##### 只要为jQuery添加通用的工具函数，都要定义在jQuery全局

#### 如何

##### 2步

###### 1. 在jQuery中划分命名空间:jQuery.自定义命名空间={}

###### 2. 在自定义命名空间中添加全局函数:jQuery.自定义命名空间.自定义函数名=function(){...}

### 封装自定义Widget

#### 封装

##### 前提:

###### 使用jquery+css成功实现过部件的完整效果

##### Step1:

###### css拷贝到部件的css文件中

##### Step2: 

###### 部件的js中

1. 判断是否提前加载了jQuery

2. 为jQuery.fn添加实例方法

向当前元素及其子元素上侵入class或data-*扩展属性

为data-*的元素绑定事件

#### 使用

##### 1. 引入部件css

##### 2. 按部件要求编写HTML内容

##### 3. 引入jquery

###### 引入部件js

##### 4. 自定义脚本

###### 查找父元素，调用部件函数
