# OOP

# 面向对象三大特点:

## 封装

### 创建一个对象，集中存储一个事物的属性和功能

## 继承

### 父对象中的成员，子对象无需重复创建，就可直接使用

## 多态

### 同一事物，在不同情况下，表现出不同的状态

# 封装——创建对象

## 也称为封装

### 将一个事物的属性和功能集中定义在一个对象中

### 事物的属性会成为对象的属性

#### 其实就是保存在对象中的普通变量

### 事物的功能会成为对象的方法

#### 其实就是保存在对象中的普通函数

### 对象的成员

#### 属性和方法统称为成员

## 何时

### 只要使用面向对象，都要先创建对象，再按需调用对象的方法执行操作

## 如何

### 3种

#### 1. 用对象直接量

```
var obj={
    属性名:属性值,
         ...  :  ... ,
    方法名: function(){
        ... this.属性名...
    }
}
```

##### 问题: 

-  对象自己的方法，访问自己的属性，如果不加this，仅会在作用域链中找，不会在对象中找

##### 解决: 

-  this.属性名

-  强调: 不带this.的变量，在作用域链中查找,this.属性在当前对象和当前对象的原型链中找

#### 2. 用new

##### 先创建一个空对象

-  var obj=new Object();

-  new可省略，()可省略，但不能同时省略

##### 为新对象添加新属性

-  obj.属性名=属性值

```
obj.方法名=function(){
    ... this.属性名 ...
}
```

##### 揭示: 

-  js中一切对象底层都是hash数组

- obj.属性名等效于obj["属性名"]

- for in 遍历每个成员

```
for(var key in obj){
    key //当前属性名
    obj[key]  //当前属性值
}
```

- 访问不存在的属性，不报错，返回undefined

- 随时添加新属性

- 但是与数组类型不同

#### 问题: 

##### 前两种方式仅适合创建一个单独的对象

#### 解决: 用构造函数反复创建多个相同结构的对象

#### 3. 用构造函数

##### 什么是

-  规定一类对象统一结构的函数

##### 何时

-  反复创建多个相同结构的对象

##### 如何

-  1. 定义构造函数

```
function 类型名(属性参数){
   this.属性名=属性参数;
   /*this.方法名=function(){
        ... this.属性名 ...
   }*///js中强烈不推荐将方法定义在构造函数中
}
```
- 2. 用new调用构造函数

var obj=new 类型名(属性值)

new:

1. 创建一个空对象

2. 设置新对象的__proto__继承构造函数的prototype对象

3. 调用构造函数，将构造函数中的this自动替换为当前新对象:构造函数将规定的属性添加到新对象中，并将传入的参数保存在新对象的新属性中

4. 返回新对象的地址保存到变量中

##### 优: 

-  代码重用

##### 缺: 

-  无法节约内存:放在构造函数中的方法，每用new调用一次，都会创建一个函数对象副本

-  解决: 继承

# this

## 什么是

### 自动引用正在调用当前方法的.前的对象

## obj.fun()

### fun中的this->obj

## new Fun()

### Fun中的this->正在创建的新对象

## fun()和匿名函数自调

### this->window

## 类型.prototype.fun()

### fun中的this->将来调用fun的.前的子对象

#### 子对象一定是当前类型

## 如果this不是想要的

### fun.call(替换this的对象)

#### 相当于 对象.fun()

# 访问对象成员

## 访问属性

### 对象.属性名

#### 用法和普通变量完全一样

### 特殊:

#### 如果访问对象的属性时，属性名需要动态拼接

##### 只能用obj["xxx"]

## 调用方法

### 对象.方法名()

#### 用法和普通函数完全一样

# 继承

## 原型对象

### 什么是

#### 集中保存同一类型的所有子对象共有成员的父对象

### 何时

#### 只要多个子对象，拥有相同的成员时，都要保存在原型对象中

### 如何

#### 创建

##### 在定义构造函数同时，已经自动创建了该类型的原型对象

##### 构造函数.prototype指向原型对象

##### 原型对象.constructor指回构造函数

#### 每创建一个新子对象，都会自动设置子对象的__proto__继承构造函数的原型对象

#### 向原型对象中添加共有成员: 

##### 构造函数.prototype.成员=值 

### 内置对象的原型对象

#### 其实内置对象类型Array,Date...都是构造函数

#### 每种类型都有自己的原型对象

##### Array.prototype, String.prototype, ..

#### 内置对象的原型中保存了所有该类型的子对象共用的API

#### 固定套路: 

##### 解决旧浏览器无法使用新API的问题

-  2步: 

1. 判断

if(类型名.prototype.方法===undefined)

2. 添加

```
类型名.prototype.方法=funciton(参数){
    ... this //获得将来调用方法的.前的对象
}
```

### 自有属性和共有属性

#### 自有属性: 

##### 直接保存在对象本地的属性

#### 共有属性: 

##### 保存在原型对象中，所有子对象共有的属性

#### 判断

##### 自有

-  var bool=obj.hasOwnProperty("属性名")

##### 共有

-  !obj.hasOwnProperty("属性名") && obj.属性名!==undefined

- 或者: 属性名 in obj : 判断属性名是否在obj的原型链中


#### 操作

##### 读取

-  子对象和原型对象都行

##### 修改

-  自有属性:必须用 子对象.属性名=值

-  共有属性:必须用 原型对象.属性名=值

## 原型链（prototype chain）

### 由各级父对象逐级继承形成的链式结构

#### 保存了

##### 所有对象的属性

#### 控制着

##### 对象成员的使用顺序

-  先用自有属性

-  自己没有，才去原型链上找

-  原型链上没有，返回undefined

#### vs 作用域链

##### 保存了

-  局部和全局变量

##### 控制着变量的使用顺序

-  先用局部变量

-  局部没有，才去作用域链上找

-  找不到，报错

## 判断对象的类型

### 0. typeof

#### 只能区分基础类型和function

#### 不能进一步区分对象的类型

### 1. var bool=类型.prototype.isPrototypeOf(child)

#### 不仅检查直接父对象，而且检查整个原型链

### 2. var bool= child instanceof 构造函数

#### 不仅检查直接父对象，而且检查整个原型链

### 问题:

#### 检查整个原型链

### 解决: 3. 检查内置class属性

#### Object.prototype.toString.call(obj)==“[object 类型名]”

#### 更严格

##### class属性直接保存在对象本地

##### 只在创建对象时确定类型

##### 对象创建后，不随继承关系的改变而改变

### 如果检查数组类型: 4. var bool=Array.isArray(obj)

#### ES5

##### IE9+

#### 原理和Object.prototype.toString.call一样

##### 方法定义在原型对象中，还是定义在构造函数对象上

-  如果方法仅限某一类对象的子对象可用，就定义在原型对象中:必须一个子对象的实例才能调用

-  如果方法不确定将来调用它的对象类型，就定义在某个构造函数对象上:不需要对象的实例，即可用构造函数名直接调用

# 多态

## 重写(override)

### 如果子对象觉得父对象的成员不好用，可在本地定义同名自有成员，来覆盖父对象中的成员

# 自定义继承

## 1. 仅修改两个对象间的继承关系:

### 获得子对象的父对象

#### var father=Object.getPrototypeOf(child)

### 设置子对象继承指定父对象

#### Object.setPrototypeOf(child,father)

## 2. 修改构造函数原型对象，来修改所有子对象的父对象

### 构造函数.prototype=father

### 时机: 

#### 必须在开始创建第一个子对象之间

## 3. 两种类型间的继承

### 何时:

#### 如果发现多个类型拥有部分相同的属性结构和方法定义

### 如何

#### 3步: 

##### 1. 定义抽象父类型

-  相同的属性结构定义在父类型的构造函数中

-  相同的方法定义在父类型的原型对象中

##### 2. 在子类型构造函数中借用父类型构造

-  extends :让父类型构造函数帮助添加相同部分的属性定义,子类型构造函数仅负责添加独有的属性定义即可

-  如何

父类型构造.call(this, 参数1,参数2,...)

父类型构造.apply(this, arguments)

-  call vs apply

相同:都是借用一个函数，并临时替换函数中this为指定对象

不同: call传入借用函数的参数，必须单独传入，逗号分隔,apply传入借用函数的参数，放在一个数组中整体传入,可自动打散数组类型参数.

##### 3. 让子类型原型对象继承父类型原型对象

-  inherits

```
Object.setPrototypeOf(
   子类型构造.prototype, 父类型构造.prototype
)
```
